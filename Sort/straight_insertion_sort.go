package Sort

/*
直接插入排序
每次从无序表中取出第一个元素，把它插入到有序表的合适位置，使有序表仍然有序。
　   第一趟比较前两个数,然后把第二个数按大小插入到有序表中; 第二趟把第三个数据与前两个数从后向前扫描，把第三个数按大小插入到有序表中；
    依次进行下去，进行了(n-1)趟扫描以后就完成了整个排序过程。
　　 直接插入排序属于稳定的排序，时间复杂性为o(n^2)，空间复杂度为O(1)。
　　 直接插入排序是由两层嵌套循环组成的。外层循环标识并决定待比较的数值。内层循环为待比较数值确定其最终位置。直接插入排序是将待比较的数值与它的前一个数值进行比较，所以外层循环是从第二个数值开始的。
    当前一数值比待比较数值大的情况下继续循环比较，直到找到比待比较数值小的并将待比较数值置入其后一位置，结束该次循环。
　　 值得注意的是，我们必需用一个存储空间来保存当前待比较的数值，因为当一趟比较完成时，我们要将待比较数值置入比它小的数值的后一位 插入排序类似玩牌时整理手中纸牌的过程。插入排序的基本方法是：
	每步将一个待排序的记录按其关键字的大小插到前面已经排序的序列中的适当位置，直到全部记录插入完毕为止。
	第一层循环是为了依次将数组中的值放入到有序表里，这里循环是从1开始，第1个元素就是有序表。比如循环进到了5，那么前五个元素就是有序表，后面的就是无序表
	第二层循环是为了形成有序表，第一次外层循环，都有一个元素放到有序表中，并形成新的有序表。

*/
func StraightInsertionSort(array []int) {
	for i := 1; i < len(array); i++ {
		temp := array[i]
		if temp < array[i-1] {
			for j := 0; j < i; j++ {
				if temp < array[j] {
					temp = array[j]
					array[j] = array[i]
					array[i] = temp
				}
			}
		}
	}
}
