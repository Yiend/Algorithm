package Sort

/*
归并排序
归并排序(Merge Sort)是利用"归并"技术来进行排序。归并是指将若干个已排序的子文件合并成一个有序的文件。归并排序有两种方式：1): 自底向上的方法 2):自顶向下的方法

 1、 自底向上的方法
（1） 自底向上的基本思想
     自底向上的基本思想是：第1趟归并排序时，将待排序的文件R[1..n]看作是n个长度为1的有序子文件，将这些子文件两两归并，若n为偶数，则得到n/2个长度为2的有序子文件；
	 若n为奇数，则最后一个子文件轮空(不参与归并)。故本趟归并完成后，前n/2 - 1个有序子文件长度为2，但最后一个子文件长度仍为1；第2趟归并则是将第1趟归并所得到的n/2个有序的子文件两两归并，如此反复，直到最后得到一个长度为n的有序文件为止。
     上述的每次归并操作，均是将两个有序的子文件合并成一个有序的子文件，故称其为"二路归并排序"。类似地有k(k>2)路归并排序。

2、自顶向下的方法(本文主要介绍此种方法，下面的文字都是对此种方法的解读)
（1） 自顶向下的基本思想
     采用分治法进行自顶向下的算法设计，形式更为简洁。
     自顶向下的归并排序：是利用递归和分而治之的技术将数据序列划分成为越来越小的半子表，再对半子表排序，最后再用递归步骤将排好序的半子表合并成为越来越大的有序序列，归并排序包括两个步骤，分别为：
      1）划分子表
      2）合并半子表

（1）分治法的三个步骤
     设归并排序的当前区间是R[low..high]，分治法的三个步骤是：
	 ①分解：将当前区间一分为二，即求分裂点
	 ②求解：递归地对两个子区间R[low..mid]和R[mid+1..high]进行归并排序；
	 ③组合：将已排序的两个子区间R[low..mid]和R[mid+1..high]归并为一个有序的区间R[low..high]。递归的终结条件：子区间长度为1（一个记录自然有序）。

如下演示递归的整个过程：
递归便是深度遍历（如下由左至右进行遍历）：假设有这样的一列数组{9,8,7,6,5,4,3,2,1}进行划分的顺序如下：
{9,8,7,6,5,4,3,2,1} --> {9,8,7,6,5}，{4,3,2,1}
{9,8,7,6,5} --> {9,8,7}，{6,5}
				{9,8,7} --> {9,8}，{7}
							{9,8} --> {9}，{8}
				{6,5} -->{6}，{5}

{4,3,2,1} --> {4,3}，{2,1}
			  {4,3} -->{4}，{3}
			  {2,1} -->{2}，{1}

当深度划分到左右数组都只剩1个元素的时候，进行上述逆序的合并：
{9}，{8} --> {8,9} 然后和 {7} --> {7,8,9}
					{6}，{5} --> {5,6}   然后 {7,8,9}和{5,6} --> {5,6,7,8,9}
						{2}，{1} --> {1,2}
						{4}，{3} --> {3,4}   然后 {1,2}和 {3,4} --> {1,2,3,4}
															 最终{5,6,7,8,9}和{1,2,3,4} --> {1,2,3,4,5,6,7,8,9}
*/
func MergeSort(array []int) {
	mergeSortFunc(array, 0, len(array)-1)
}

//归并排序（目标数组，子表的起始位置，子表的终止位置）
func mergeSortFunc(array []int, first, last int) {
	//子表的长度大于1，则进入下面的递归处理
	if first < last {
		mid := (first + last) / 2                //子表划分的位置
		go mergeSortFunc(array, first, mid)      //对划分出来的左侧子表进行递归划分
		go mergeSortFunc(array, mid+1, last)     //对划分出来的右侧子表进行递归划分
		go mrgeSortCore(array, first, mid, last) //对左右子表进行有序的整合（归并排序的核心部分）
	}
}

//归并排序的核心部分：将两个有序的左右子表（以mid区分），合并成一个有序的表
func mrgeSortCore(array []int, first, mid, last int) {
	leftIndex := first          //左侧子表的起始位置
	rightIndex := mid + 1       //右侧子表的起始位置
	temp := make([]int, last+1) //声明数组（暂存左右子表的所有有序数列）：长度等于左右子表的长度之和。

	tempIndex := 0
	//进行左右子表的遍历，如果其中有一个子表遍历完，则跳出循环
	for leftIndex <= mid && rightIndex <= last {
		//此时左子表的数 <= 右子表的数
		if array[leftIndex] <= array[rightIndex] {
			//将左子表的数放入暂存数组中，遍历左子表下标++
			temp[tempIndex] = array[leftIndex]
			tempIndex++
			leftIndex++

		} else { //此时左子表的数 > 右子表的数
			//将右子表的数放入暂存数组中，遍历右子表下标++
			temp[tempIndex] = array[rightIndex]
			tempIndex++
			rightIndex++
		}

	}

	for leftIndex <= mid {
		//有一侧子表遍历完后，跳出循环，将另外一侧子表剩下的数一次放入暂存数组中（有序）
		temp[tempIndex] = array[leftIndex]
		tempIndex++
		leftIndex++
	}

	for rightIndex <= mid {
		temp[tempIndex] = array[rightIndex]
		tempIndex++
		rightIndex++
	}

	//将暂存数组中有序的数列写入目标数组的制定位置，使进行归并的数组段有序
	tempIndex = 0
	for i := first; i < last; i++ {
		array[i] = temp[tempIndex]
		tempIndex++
	}
}
